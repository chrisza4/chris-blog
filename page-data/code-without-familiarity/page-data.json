{"componentChunkName":"component---src-templates-blog-post-js","path":"/code-without-familiarity/","result":{"data":{"site":{"siteMetadata":{"title":"Chris' Dialogue"}},"markdownRemark":{"id":"5a2b817b-64f5-5fe1-a55d-81b8bc748530","excerpt":"หลายๆ ครั้งผมพบว่าโปรแกรมเมอร์มักจะตัดสินคุณภาพของโค้ดจากปัจจัยเพียงแค่ว่า Pattern ที่เขาใช้ตรงกับที่เราใช้มั้ย เช่น ถ้าสมมติเราทำโค้ด MVC…","html":"<p>หลายๆ ครั้งผมพบว่าโปรแกรมเมอร์มักจะตัดสินคุณภาพของโค้ดจากปัจจัยเพียงแค่ว่า Pattern ที่เขาใช้ตรงกับที่เราใช้มั้ย</p>\n<p>เช่น ถ้าสมมติเราทำโค้ด MVC อาจจะมีทีมนึงกำหนดกฎไว้แบบนี้</p>\n<ul>\n<li>Controller ห้ามมี Logic</li>\n<li>ใน View ให้เข้าถึง Model แล้วถ้าอยากแสดงอะไรพิเศษให้เพิ่มใน Model</li>\n<li>Model เป็นที่รวม Logic ส่วนมาก รวมถึงการเข้าฐานข้อมูล</li>\n<li>ให้ใช้ Dependency Injection ในการทำให้ Unit test ได้</li>\n</ul>\n<p>ทีนี้เวลาเราไปเจอโค้ดของอีกทีมที่ใช้ Pattern อีกอย่างกับที่เราคุ้นชิน เช่น</p>\n<ul>\n<li>หากต้องการแสดงอะไรพิเศษให้สร้าง Presenter หรือ ViewModel ขึ้นมา</li>\n<li>Controller มี Logic ในการตรวจสอบ Request ได้</li>\n<li>ให้ใช้ Stub ในการทำให้ Unit test ได้</li>\n</ul>\n<p>เราก็อาจจะคิดว่าโค้ดนั้นห่วยเพราะมันไม่ถูกต้องตามที่เราเรียนมาหรือคุ้นชินมา</p>\n<p>ผมมองว่าการใช้ความคุ้นชินแบบนี้เป็นตัวชี้วัดว่าโค้ดมีคุณภาพมั้ยที่ไม่ดีมากๆ โค้ดหลายตัวมีคุณภาพที่ดีโดยไม่จำเป็นต้องใช้ Design Pattern ที่เรารู้จัก ตัวเราเองก็ไม่สามารถไปอ่านหรือทำความเข้าใจทุกๆ Design Pattern บนโลกนี้ได้</p>\n<p>ผมมีโอกาสอ่านโค้ดของ Candidate ทำงานกับ Legacy code มาเยอะ มีโอกาสเขียนโปรแกรมมาหลากหลายภาษา แต่ละภาษาแต่ละโค้ดเองก็มีทั้งสไตล์, Framework, Design decision, Best practices ที่แตกต่างกัน</p>\n<p>ด้วยประสบการณ์แบบนี้ ผมไม่อยู่ในฐานะที่สามารถบอกได้ว่าโค้ดไหนแย่หรือดีจากเพียงแค่เพราะมันคุ้นตามั้ย แค่เปลี่ยนภาษาก็จบเห่แล้ว ทุกอย่างต้องลบทิ้งหมด อย่างเช่น</p>\n<ul>\n<li>วันที่ผมเปลี่ยนจาก Angular มาเป็น React งี้ ผมไม่สามารถบอกได้ละว่าโค้ดที่ดีต้องมี Dependency injection ใน React มันไม่เหมาะเอามากๆ</li>\n<li>วันที่ผมใช้เทคโนโลยี Web API กับ MVC เพื่อเขียน C# JSON API Application ก็มีความแตกต่างมากในแง่ของ Entity ที่ใช้ในระดับ API ผูกกับ Object ขนาดไหน อันนึงออกแบบบนฐานของ Coupling Entity, Response กับอีกอันคือ Decoupling เลย</li>\n<li>ตอนผมทำ Rails, C# MVC, Phoenix ถึงแม้จะเป็น MVC เหมือนกันแต่สไตล์ก็แตกต่างกันมาก</li>\n</ul>\n<p>ผมจึงอยากแชร์ว่าปกติแล้วผมดูอย่างไรว่าโค้ดไหนดีหรือโค้ดแบบไหนแย่ โดยไม่ขึ้นกับความคุ้นตาของตัวเอง</p>\n<p>งั้นเรามาเริ่มกันเลยดีกว่า</p>\n<h2>Definition</h2>\n<p>กฎข้อแรกที่สำคัญที่สุดของโค้ดที่ดีสำหรับผมคือ</p>\n<p><strong>โค้ดที่ดีสำหรับผมคือมีนิยามของคำศัพท์ที่ชัดเจน และทำตามนิยามนั้น</strong></p>\n<p>ผมยกตัวอย่าง Rails บอกว่า <a href=\"https://guides.rubyonrails.org/action_controller_overview.html\">Controller</a></p>\n<blockquote>\n<p>Action Controller is the C in MVC. After the router has determined which controller to use for a request, the controller is responsible for making sense of the request, and producing the appropriate output. Luckily, Action Controller does most of the groundwork for you and uses smart conventions to make this as straightforward as possible.</p>\n</blockquote>\n<p>แปลว่า Controller มีหน้าที่จัดการ Request และจัดการ Output ถ้าเรานิยามไว้แบบนี้ แปลว่าโค้ดที่เอา Controller ไปทำอย่างอื่นคือไม่ดีละ</p>\n<p>แปลว่าผมอ่านโค้ด Rails ผมจะไม่อยากเห็น Controller ที่รู้เรื่องธุรกิจภายในมากกว่าการจัดการ Request/Response</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">TransactionController</span>\n<span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">create</span></span>\n  <span class=\"token keyword\">raise</span> <span class=\"token constant\">TooLowTransactionError</span> <span class=\"token keyword\">if</span> params<span class=\"token punctuation\">[</span><span class=\"token symbol\">:amount</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span> <span class=\"token comment\"># บรรทัดนี้คือไม่ดี เพราะมันรู้ว่าในธุรกิจของเราห้ามสร้าง Transaction ต่ำกว่า 20 บาท</span>\n  <span class=\"token comment\"># ....</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>ซึ่งแปลว่าถ้ามีใครก็ตามกำหนด Definition ของ Controller ต่างไปจากเรา เราอาจจะเอ๊ะในครั้งแรกว่าทำไมถึงกำหนดต่างกับมาตรฐานสากลล่ะ แต่ไม่ได้แปลว่าโค้ดไม่ดีนะครับ</p>\n<p>สมมติใครซักคนกำหนดว่า Controller มีหน้าที่ประสานงานระหว่าง Model ในกรณีที่ API นั้นต้องใช้มากกว่า 1 Model แล้วเขาเขียนตามนั้น นี่ก็คือถือว่ายังเป็นโค้ดที่ดีในแง่ของ Honest to definition อยู่ครับ</p>\n<p>ส่วนการกำหนด Definition แบบนี้มันเหมาะหรือไม่ จะทำให้ Controller บวมเกินเหตุมั้ย อันนั้นอีกเรื่องนึง ต้องไปดูตามบริบทของระบบที่พัฒนาอีกทีนึง</p>\n<p>หรืออย่างเช่นใน MVC แบบ Rails ตัว Model จะเข้าถึงฐานข้อมูลได้ ก็จะเขียนบอกไว้ใน Definition ของ Model แต่ถ้าเราเริ่มทำ Hexagonal Architecture เราอาจจะมี Repository ที่เข้าถึงข้อมูลอีกที ไม่ให้ Model เขาถึงฐานข้อมูลโดยตรง</p>\n<p>ทั้งสองอย่างผมมองว่าไม่ได้มีอันไหนเหนือกว่าอันไหน ขึ้นกับบริบทของระบบ</p>\n<p>แต่สิ่งที่ดีเสมอโดยไม่ขึ้นกับบริบท คือคุณมีนิยามที่ชัดเจนว่าแต่ละคำศัพท์แปลว่าอะไร และคนร่วม Contribute เข้าใจตรงกันไม่สับสน สามารถทดสอบได้ง่ายๆ คือ สมมติพูดถึง Controller ถ้าผมเป็นสมาชิกใหม่เข้าไปถามว่า สิ่งนี้ควรอยู่ใน Controller มั้ย ทุกคนควรจะตอบได้ตรงกัน</p>\n<p>สิ่งที่แย่โดยโดยไม่ขึ้นกับบริบท คือ นิยามที่ว่าแต่ละคำศัพท์คืออะไรมันกำกวม คนร่วมทีมอธิบายไม่ได้ว่า Model แปลว่าอะไร Controller แปลว่าอะไร ไปถามเจ้าตัวคนเขียนคนแรกก็ตอบไม่ได้ชัดเจนว่านิยามอะไร บอกได้แค่ประมาณนั้นอ่ะประมาณนี้อ่ะ แต่ละคนในทีมตอบไม่ตรงกันซักคน</p>\n<p>อันนี้ผมมองว่าแย่เสมอในทุกบริบทของระบบ</p>\n<h2>Consistency</h2>\n<p>ต่อเนื่องจากนิยาม ความคงเส้นคงวาก็สำคัญ</p>\n<p>ผมขอยกย่อหน้าเก่าขึ้นมา</p>\n<blockquote>\n<p>หรืออย่างเช่นใน MVC แบบ Rails ตัว Model จะเข้าถึงฐานข้อมูลได้ ก็จะเขียนบอกไว้ใน Definition ของ Model แต่ถ้าเราเริ่มทำ Hexagonal Architecture เราอาจจะมี Repository ที่เข้าถึงข้อมูลอีกที ไม่ให้ Model เขาถึงฐานข้อมูลโดยตรง</p>\n</blockquote>\n<p>ถ้าสมมติเราวางนิยามไว้แบบนี้ แต่บางทีเวลาเห็น Model บวมเราก็สร้าง Repository ขึ้นมา บางทีก็ใช้ บางทีก็ไม่ใช้ ไม่มีความคงเส้นคงวา อันนี้ก็ถือว่าไม่ดี</p>\n<p>ไม่ว่าจะทำโค้ดในภาษาโบราณแค่ไหนไปจนถึงใหม่แค่ไหน ความคงเส้นคงวาของคำศัพท์และ Layering คือดีครับ และข้อยกเว้นยิ่งมีมากคือไม่ดี</p>\n<p>หรือสมมติถ้าเราตกลงกันแล้วว่าเราจะใช้ <code class=\"language-text\">map</code> เสมอ เราก็จะใช้มันเสมอ ไม่ใช้ for loop และตรงข้าม ถ้าเราตกลงกันแล้วว่าจะใช้ for loop เสมอไม่ใช้ <code class=\"language-text\">map</code> ก็ควรจะคงเส้นคงวากับสิ่งนั้น</p>\n<p>ถ้าจะใช้ผสมกันก็ต้องบอกได้ว่าตอนไหนใช้ <code class=\"language-text\">map</code> ตอนไหนใช้ loop ที่ชัดเจนเข้าใจตรงกัน</p>\n<p>การมีข้อยกเว้นได้มั้ย ได้ ถ้า Justify the cost ได้ แต่ถ้ามีไปเฉยๆ โดยไม่มีต้นสายปลายเหตุอธิบายได้ดีว่าทำไมถึงเกิดข้อยกเว้น อันนี้ผมมองว่าแย่โดยไม่เกี่ยวกับว่าออกแบบยังไง</p>\n<h2>Appropriate coupling</h2>\n<p>โค้ดที่ดีอีกอย่างนึงคือ เราเข้าใจว่าโค้ดแต่ละบรรทัดแก้ไขแล้วมีสิทธิ์กระทบอะไรบ้าง</p>\n<p>ผมยกตัวอย่างจากบทความที่ผมเขียนเองเรื่อง <a href=\"https://dev.to/chrisza4/code-clean-13kk\">โค้ดเหมือนจะ Clean</a></p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Invoice</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">pay_invoice</span></span>\n    make_sure_invoice_approved\n    create_transaction_entry\n    decrease_company_total_balance\n    record_tax_deduction\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>ถ้าเราเขียนแบบนี้แล้วเราไม่สามารถทำความเข้าใจได้ว่าการแก้ไข <code class=\"language-text\">create_transaction_entry</code> จะกระทบกับใบเสร็จส่วนไหนบ้าง จนกว่าจะขุดลึกๆ อันนี้คือแย่</p>\n<p>ดังนั้นการออกแบบให้ Dependency ระหว่างโค้ดแต่ละส่วนเคลียร์ เข้าใจง่าย ไม่พันกันเกินไป จนสามารถพูดได้เต็มปากว่าถ้าผมแก้โค้ดบรรทัดนี้ ส่วนนี้อาจจะกระทบ และส่วนนั้นจะไม่กระทบแน่นอน</p>\n<p>นั่นคือคุณลักษณะของโค้ดที่ดี โดยไม่เกี่ยวกับ Design pattern ที่ใช้</p>\n<h2>Local reasoning</h2>\n<p>คุณสมบัติสุดทายที่ผมจะพูดถึงวันนี้คือ Local reasoning หรือความสามารถในการทำความเข้าใจแยกส่วนได้</p>\n<p>ถ้าคุณเห็นโค้ดแบบนี้</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">run</span></span>\n  <span class=\"token comment\"># ทำทุกอย่าง</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>โปรแกรมลักษณะนี้เราต้องเข้าใจทุกอย่างที่มีในระบบก่อนที่จะแก้ไขบรรทัดนึง เพราะแต่ละบรรทัดอาจจะขึ้นกับบรรทัดอื่นได้โดยที่เราไม่รู้ จึงทำให้การทำความเข้าใจแค่ส่วนที่เราสนใจทำไม่ได้</p>\n<p>แต่ถ้าเป็นแบบนี้ล่ะ</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">vat</span></span>\n  <span class=\"token variable\">@amount</span> <span class=\"token operator\">*</span> <span class=\"token number\">0.07</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>เราเร่ิมเข้าใจได้ละว่าบรรทัดนี้ขึ้นกับจำนวน <code class=\"language-text\">@amount</code> ในคลาสของเราเท่านั้น โดยมั่นใจได้ 100% ว่าจะไม่มี Surprise ใดๆ ออกมาที่จะมากระทบกับสิ่งนี้แบบงงๆ ได้ นอกจาก Amount</p>\n<p>การที่เราสามารถทำความเข้าใจโค้ดเป็นส่วนๆ ได้ก็สำคัญ และเป็นสาเหตุนึงที่โค้ดที่ดีมักจจะมีขนาดของ Function, Method ที่เล็ก (แต่ผมว่าเราเชียร์ว่าทำฟังก์ชั่นเล็กๆ มากไปหน่อย จนหลายๆ คนเชื่อว่าฟังก์ชั่นเล็กคือดี โดยไม่เข้าใจว่าดียังไง ผมตอบให้ว่าจริงๆ เราอยากได้ความสามารถในการทำ Local reasoning)</p>\n<h2>ส่งท้าย</h2>\n<p>จริงๆ แล้วมันมีปัจจัยอีกมากมายที่ผมดู แต่วันนี้ขอเสนอ 4 ข้อครับ</p>\n<ul>\n<li>Domain alignment</li>\n<li>Naming convention</li>\n<li>etc.</li>\n</ul>\n<p>แต่ 4 ข้อนี้เป็นข้อพื้นฐานที่ผมคิดว่าถ้าเริ่มมองโค้ดที่ไม่คุ้นชินจากมุมนี้ เราจะเข้าใจง่ายขึ้นว่าโค้ดที่ดีเป็นแบบไหน รวมไปถึงถ้าเราไปศึกษา Framework ใหม่ โดยเข้าใจว่า Framework ที่ดีจะมีคุณสมบัติพวกนี้ เราก็จะเข้าใจและคาดเดา (Deduce) Design บางอย่างได้อย่างรวดเร็วครับ อ่านแป๊ปเดียวก็อ๋อ เขาไว้ยังงี้นี่เอง ได้เร็วขึ้นครับ</p>\n<p>ถ้าชอบบทความนี้ ผมรบกวนกดให้กำลังใจใน <a href=\"https://dev.to/chrisza4/code-quality-3pm\">dev.to</a> ด้วยครับ บล็อกนี้ยังไม่ได้ทำระบบ Like หรือ View</p>","frontmatter":{"title":"Code quality without familiarity","date":"March 07, 2021","description":null}},"previous":{"fields":{"slug":"/design-upfront/"},"frontmatter":{"title":"Agile upfront design"}},"next":{"fields":{"slug":"/persona-based-architecture/"},"frontmatter":{"title":"Persona-based architecture"}}},"pageContext":{"id":"5a2b817b-64f5-5fe1-a55d-81b8bc748530","previousPostId":"25261e5b-a01b-5784-99e9-c89ee60df484","nextPostId":"f3e25b63-ef81-5e25-b37f-6aa8dd0a949a"}},"staticQueryHashes":["1033745147","2841359383"]}