{"componentChunkName":"component---src-components-course-course-js","path":"/large-scale-course/","result":{"data":{"site":{"siteMetadata":{"title":"Chris' Dialogue"}},"markdownRemark":{"id":"a0f34946-7e04-560b-93db-a817af03ab35","excerpt":"Summarized เข้าใจพื้นฐานการออกแบบระบบขนาดใหญ่ ศัพท์ต่างๆ และแนวคิดที่จำเป็น เพื่อให้ระบบมีโอกาสล่มน้อย (Fault tolerance…","html":"<h2>Summarized</h2>\n<p>เข้าใจพื้นฐานการออกแบบระบบขนาดใหญ่ ศัพท์ต่างๆ และแนวคิดที่จำเป็น เพื่อให้ระบบมีโอกาสล่มน้อย (Fault tolerance) และมีประสิทธิภาพที่ยอมรับได้ มีข้อผิดพลาดน้อย</p>\n<p>หลายๆ ครั้งผมพบว่าการออกแบบระบบขนาดใหญ่ที่สอนกันในเมืองไทยมักจะสอนเรื่องการใช้เทคโนโลยีเฉพาะทาง เช่น Cloud, Database, Queue, etc. ทำให้การออกแบบมักจะยึดคิดที่เทคโนโลยี คอร์สนี้ตั้งใจจะสอนเรื่องหลักคิดและ Primitive ต่างๆ ที่สำคัญในการออกแบบ Large scale distributed system เพื่อให้เราสามารถออกแบบได้โดยไม่ยึดติดกับเทคโนโลยีโดยเฉพาะ</p>\n<p>คลาสนี้จะสอนให้เข้าใจว่าประเด็นในการออกแบบระบบสเกลใหญ่มันมีประเด็นหลักๆ อะไรบ้าง แล้วเวลาที่เราเลือกเทคโนโลยี เราจะอ่าน Design Documentation ของระบบต่างๆ เช่น Load Balancer, Database, Memory Cache, Cluster Management อย่างไรเพื่อให้ได้ประโยชน์ในการออกแบบระบบเรา และพอเราเข้าใจแล้ว เราสามารถได้ข้อดี และเข้าใจวิธีการเตรียมพร้อมรับมือ Trade-offs และ Downside ต่างๆ ของระบบเหล่านั้นได้ ซึ่งการจะเข้าใจจุดนี้ได้เราจำเป็นต้องเข้าใจ Primitive และ Pattern ของ Large scale distributed system เช่น Atomicity, Monotonicity, Replication, Consensus, Partitioning, etc. ซึ่งผมตั้งใจจะสอนให้มากพอที่คุณจะไปใช้ต่อได้ และยกตัวอย่างให้เห็นว่าเทคโนโลยีที่เป็นที่นิยมในปัจจุบันใช้ทฤษฎีพวกนี้เหมือนหรือต่างกันอย่างไรบ้าง</p>\n<h2>เหมาะสำหรับ</h2>\n<ul>\n<li>คนเรียนที่เคยเขียนโปรแกรมมา 3-5 ปีและเริ่มสนใจการออกแบบระบบขนาดใหญ่</li>\n<li>Architect, Engineering manager ที่จำเป็นต้องมีส่วนร่วมในการออกแบบระบบขนาดใหญ่ หรือรีวิว</li>\n</ul>\n<h2>เนื้อหาโดยคร่าว (อาจเปลี่ยนแปลงได้)</h2>\n<ol>\n<li>\n<p>What is scalable? เข้าใจประเด็นและความหมายของ Scalability เช่น Latency vs. Throughput, Naive scaling model, Scaling time, Theory of constraint</p>\n</li>\n<li>\n<p>Concurrent state, the root of all problems เข้าใจความยุ่งยากและประเด็นละเอียดอ่อนเวลาที่มีข้อมูลที่ต้องได้รับการ Access พร้อมๆ กันเป็นจำนวนมาก และ Primitive ที่ใช้ในการโมเดล เช่น Process, Thread, Stateless, Stateful, Atomiticy, Mutex, Semaphore, Isolation level, Deadlock Detection, Message passing (which is original purpose of OOP) เพื่อให้สามารถออกแบบระบบที่มีคนเข้าถึงข้อมูลพร้อมๆ กันเป็นจำนวนมาก แต่ไม่มีข้อผิดพลาดในข้อมูลได้</p>\n</li>\n<li>\n<p>Distributed system: Fault tolerance รู้จักการออกแบบระบบที่ทนทานต่อความล้มเหลวเป็นส่วนๆ เช่น Server บางตัวพัง และทฤษฎีที่จำเป็น เข้าใจ Two-general problems, CAP, Idempotency, Ordering problem, Single point of failure, Monotonicity, Consensus</p>\n</li>\n<li>\n<p>Common scaling patterns and principle: แชร์วิธีคิดเบื้องต้นที่ใช้เวลาออกแบบระบบขนาดใหญ่ ว่าจะเริ่มคิดจากจุดไหนดี</p>\n</li>\n</ol>","frontmatter":{"title":"Designing large scale system: The fundamentals","date":null,"description":"เข้าใจพื้นฐานของการออกแบบระบบขนาดใหญ่"}},"previous":null,"next":null},"pageContext":{"id":"a0f34946-7e04-560b-93db-a817af03ab35","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["2841359383"],"slicesMap":{}}