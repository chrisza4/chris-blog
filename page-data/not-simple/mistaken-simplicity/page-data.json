{"componentChunkName":"component---src-templates-blog-post-js","path":"/not-simple/mistaken-simplicity/","result":{"data":{"site":{"siteMetadata":{"title":"Chris' Dialogue"}},"markdownRemark":{"id":"9fa0e9dc-6e90-5e54-b780-166fbda9c56b","excerpt":"For the past few years I found one commmon fallacy trope. “Stop introduce more technology. Just use X for everything. It will be much simpler.” This trope can…","html":"<p>For the past few years I found one commmon fallacy trope.</p>\n<p>“Stop introduce more technology. Just use X for everything. It will be much simpler.”</p>\n<p>This trope can range from <a href=\"https://www.amazingcto.com/postgres-for-everything/\">Postgres</a>, Make, HTML-CSS-JS and so-on.</p>\n<p>While I think there is a lot of merit in limiting amount of technology stacks in organization and I’ve seen many unjustifiably complicated systems consist of 10 frameworks and 20+ tech stack behind the scene just because devs want to play with new shiny toy. I also think the position of just use “X” is pretty bad in its own way.</p>\n<p>Because, simply put, why “X” when we can also use “Y” for everything as well.</p>\n<p>Take Postgres for example: technically speaking we can use Postgres to build queue, to do a full-text search and possibly Redis replacement according to <a href=\"https://www.amazingcto.com/postgres-for-everything/\">this article</a>. But one thing that I might argue: Why Postgres over, let say, SQL Server or MySQL or just plain old boring file?</p>\n<p>There might be some technical answer to this question. But I guarantee most of the times it’s because the speaker is proficient in Postgres.</p>\n<p>Implementing queue in Postgres <a href=\"https://www.reddit.com/r/programming/comments/zk3hbg/comment/j0031fy/?utm_source=share&#x26;utm_medium=web2x&#x26;context=3\">is not that easy and require a lot of experience to nail it right</a>. I would bet using Postgres as Redis replacement would have even more edge cases and concern.</p>\n<p>In the eye of Postgres expert, it is simple. In the eye of everyone else, it’s super complicated.</p>\n<p>And this is where the fallacy lie in. Someone who familiar with X will say that using X for everything is simple because you just need to learn X. And they might forget how it took them years of experience until one start to find X simple.</p>\n<p>C++ can also be very simple for someone btw.</p>\n<p>I know someone who advocate for using Makefile for everything infra relate because he is so proficient at it. He can’t see why we need to embed our script into <code class=\"language-text\">package.json</code> or using few lines of Python/Go for cli task. Then I know someone who advocate for using Python for every cli task because “It’s simpler. Everyone know about Python right?“.</p>\n<p>And I can imagine how they will fight and pointing finger to each other for “introducing needless complexity”. Why don’t you embrace simplicity and just use X for everything?</p>\n<p>I agree with general concept of limiting technology stack. Sadly most of the times it isn’t really about general concept of simplicity, it’s about using technology that the advocater familiar with.</p>\n<p>Here is a litmus test. If you advocate for using X for everything because simplicity then consider this. When your team said that Y can achieve the same and everyone else except you is more productive with Y, will you change your mind and advocate for using Y for everything instead? Will you drop your expertise on X and advocate for Y for sake of simplicity? (Assuming Y can achieve this technically speaking)</p>\n<p>In general, is it really about priniple of simplicity by using one technology or is it about using what you already familiar with?</p>\n<p>I usually agree with principle of simplicity but I find it is very rare to see true believer. It’s usually more about just get back and use what I learned for the past 10 years rather than simplifying technology stacks.</p>\n<p>Also, we can technically use C or Assembly for everything. Radical simplicity has its own limit. What grind my gear is how people usually draw the line. It’s almost always like what I am currently good at is inherently simple and what I don’t know is needless complexity since I can use what I am good at to achieve the same.</p>\n<p>General simplicity shouldn’t care much about your personal expertise, don’t you think?</p>\n<p>Modified from Douglas Adam quotes, it’s almost like this:</p>\n<ol>\n<li>\n<p>Anything that is in the world when you’re start your tech career is normal and ordinary and is just simple technologies we all should rely on.</p>\n</li>\n<li>\n<p>Anything that’s invented between when you’re first to ten years of tech career is new and exciting and revolutionary and have so much potential.</p>\n</li>\n<li>\n<p>Anything invented after that is a blatantly complex technology created by clueless kids who just reinvent the wheel.</p>\n</li>\n</ol>\n<p>Moral of story: If you believe in simplicity of using fewer framework and tech, don’t stick with just technologies that you know. Otherwise, you aren’t into principle that much to begin with.</p>","frontmatter":{"title":"Simplicity fallacy of \"Just use X (for everything)\"","date":"December 14, 2022","description":null}},"previous":{"fields":{"slug":"/tdd-misconception/"},"frontmatter":{"title":"TDD Misconception: You can write some design code before test"}},"next":{"fields":{"slug":"/security-part-of-solution/"},"frontmatter":{"title":"Dear Security, be a part of the solution"}}},"pageContext":{"id":"9fa0e9dc-6e90-5e54-b780-166fbda9c56b","previousPostId":"0189af1e-4cbe-5881-8c49-c7a032d30011","nextPostId":"818a74e8-46a2-51c9-9d03-fd1e178dd78f"}},"staticQueryHashes":["1033745147","2841359383"],"slicesMap":{}}