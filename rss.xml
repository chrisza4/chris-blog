<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Chris' Dialogue]]></title><description><![CDATA[A blog of Chris, a human who love to learn more about himself and the world]]></description><link>https://gatsby-starter-blog-demo.netlify.app</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 16 Apr 2021 14:48:48 GMT</lastBuildDate><item><title><![CDATA[Persona-based architecture]]></title><description><![CDATA[We developers always dream about a maintainable system. We longed for a simple system that is easy to work with. It should be easy to change…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/persona-based-architecture/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/persona-based-architecture/</guid><pubDate>Wed, 14 Apr 2021 17:00:00 GMT</pubDate><content:encoded>&lt;p&gt;We developers always dream about a maintainable system. We longed for a simple system that is easy to work with. It should be easy to change, debug and observe.&lt;/p&gt;
&lt;p&gt;We created a concept called clean code and clean architecture in order to pursue that dream.&lt;/p&gt;
&lt;p&gt;What is clean architecture? There is a definition defined by &lt;a href=&quot;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&quot;&gt;Uncle Bob&lt;/a&gt;. It must be independent of a framework. It must be independent of UI, etc.&lt;/p&gt;
&lt;p&gt;Everything seems good. Since we have a solid ground on what a clean code is, we should already achieve a maintainable codebase, right?&lt;/p&gt;
&lt;p&gt;Surprisingly, whenever I had a conversation with developers who work with those clean architecture patterns. I asked them how it is in practice. Does the team become more effective? Do the team happy with the codebase?&lt;/p&gt;
&lt;p&gt;The answer usually goes like this.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Well, it is not really easy for a common developer. They need to learn multiple concepts and take a lot of time to become effective.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Wait. In a quest to chase a maintainable codebase, we accidentally created a codebase that is hard to maintain, did we?&lt;/p&gt;
&lt;h3&gt;Practical maintainability&lt;/h3&gt;
&lt;p&gt;Personally, I have no issue working with great architectural patterns such as &lt;a href=&quot;&quot;&gt;Hexagonal Architecture&lt;/a&gt;, &lt;a href=&quot;&quot;&gt;CQRS&lt;/a&gt;, &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; &lt;a href=&quot;&quot;&gt;Microservices&lt;/a&gt;. I learned about this pattern for quite a while.&lt;/p&gt;
&lt;p&gt;But when I work in a team of 10 developers, does it matter if I am the only one out of nine who knows about it?&lt;/p&gt;
&lt;p&gt;We know that a maintainable codebase must have dependency inversion, low coupling, high cohesion, follow SOLID principle, follow DRY principle, etc. Surprisingly, when we follow all the maintainable codebase rules and at the end, the team might find it hard to work with.&lt;/p&gt;
&lt;p&gt;What happens? Are we chasing an illusion of a maintainable codebase? Are we a bunch of sheep that blindly follow the shepherd rules with false hope of promised maintainable land?&lt;/p&gt;
&lt;p&gt;I think when we follow all those rules and theories, we achieve theoretical maintainability. Any codebase with all those characteristics should be maintainable, in theory.&lt;/p&gt;
&lt;p&gt;In practice, I think maintainability should simply be defined like this.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A maintainable codebase is a codebase that a team can effectively work with.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That’s it—such a simple definition.&lt;/p&gt;
&lt;p&gt;All those rules about dependency inversion, coupling, cohesion, SOLID, DRY are just tools to achieve the dream. We should understand those concepts in order to create a maintainable codebase. But they should never be viewed as a goal in itself.&lt;/p&gt;
&lt;p&gt;Is the CQRS codebase maintainable? If a team finds it easy to work with, then yes.&lt;/p&gt;
&lt;p&gt;In the end, the maintainability of any codebase never depends on whether you do things in the right way or follow best practices. While it helps, it is not a deciding factor.&lt;/p&gt;
&lt;p&gt;It all depends on &lt;strong&gt;humans&lt;/strong&gt;. Yes, those fuzzy emotional unreliable humans.&lt;/p&gt;
&lt;h3&gt;Working with human&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Once, a software architect said this to me: Software Architect is a very special role. We are responsible for the overall quality of the codebase. We know the quality of the codebase depends on developers. And yet, we don’t have any power to hold those developers accountable. We can only design, convince, and maybe set some rules.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A path toward maintainable architecture is such a vague path. Since it all depends on humans, there is no correct answer. No matter what you do, you might be right, or you might be wrong.&lt;/p&gt;
&lt;p&gt;Software engineers are familiar with working with binary. There will always be a right way. Code should either compiled or error. Code should either pass a test or fail a test. Everything should be consistent and reproducible.&lt;/p&gt;
&lt;p&gt;On the other hand, humans are not consistent at all. Today a human can love one thing, and tomorrow they might hate it. They might say our codebase is the best codebase ever today, and in the next few months, they might want to rewrite everything from scratch.&lt;/p&gt;
&lt;p&gt;How can we work with humans?&lt;/p&gt;
&lt;p&gt;I would like to introduce you to two fields that are pretty much in the same spot.&lt;/p&gt;
&lt;p&gt;The first field is the design field. Designers never have direct control over users, yet they need to design both UX and UI to guide users to do the right thing. Their career pretty much depends on the user doing the right thing while still happy with the overall experience.&lt;/p&gt;
&lt;p&gt;The second field is the economic field. Economic planners never have direct control over the population behavior, yet they need to create a system that incentivizes people to a certain economic direction. Otherwise, the whole nation failed.&lt;/p&gt;
&lt;p&gt;I am always fascinated by behavioral economics. How can you introduce a policy? How will people react to that? What will be the consequence?&lt;/p&gt;
&lt;p&gt;There are many tools and ways of thinking from those fields that we can apply to software architecture. I can name many. Design thinking, User testing, Unintended consequence, Game Theory, etc. All those tools are applicable to software architecture.&lt;/p&gt;
&lt;p&gt;And today, I will write about a tool that I steal from the design field: &lt;strong&gt;Persona&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Persona&lt;/h3&gt;
&lt;p&gt;According to Wikipedia, here is a definition of persona&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A persona (also user persona, customer persona, buyer persona) in user-centered design and marketing is a fictional character created to represent a user type that might use a site, brand, or product in a similar way&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, whenever designers design anything, they create a fictional character of their user. And we can adopt this practice of creating a fictional character of maintainers.&lt;/p&gt;
&lt;p&gt;There are many ways to create a persona in product development. To get back to software architecture, I think persona of maintainers should consist of two parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Context. What is the experience level of our fellow developers? What is their role? What will they do on a day-to-day basis?&lt;/li&gt;
&lt;li&gt;Expectation. Based on context and our design, what are our expectations?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The context helps you empathize with the capability, limitation, and habit of maintainers. That will be an architectural design constraint. On the other hand, expectation helps you understand what you expect from each.&lt;/p&gt;
&lt;p&gt;For example, let say we want to adopt microservice architecture. Here is a persona example:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/29476eef551e2dc9d5adb159b9b892f2/bce72/Personas.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 86.0759493670886%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQ4y41USYpqQRAs8BqeQATBvQsP4wnceABXLj2ElxDFeZ4VBxzaeWwnWnE2PlFQYj9bvglJ5ZuioiIjn+j3+3C5XLDb7WAsFguZ2rjdbrjf7zIZz/VzCL/fD4vFAr1eL1+4XC5oNBpot9sYjUbo9Xo4HA6/PvoL6AFotVqh0+kghIDb7ZY3u90uvF4vgsEgAoEAms2mBG61WlitVr8YahkLm80Gs9kMo9EIj8cjH85mM+RyOVQqFeTzeSSTScm60+m8yKEFFVrKu90Og8EAX19fmM/nOJ1OOB6Pv47JmpoytcDier1CJV/gSjbxeByZTAb1eh2lUgnFYhGFQkEy5jXrdDotpSCJh4bPWigWfCmVSknQaDSKWCyGSCQiwbhZrVZ7rNPpFPv9HufzWab4Swt2N5FIIJvNSiAyISilWC6XEoQ6s+bKpP0okVB68KjP+nA3Wogaqt0/CfGpv7RWeZfi5+dHHomeY2w2G5n/A31HQLCTNDcnRY0YNaHoNDK9yJo2Go/HL0bWgguHwwGDwSABfT7fo8usw+GwZE+T0z4EHQ6HUu+3gCaTSY4d0+l0ypvsIj/k+mzeT7QVtEi1WkW5XAb1ZFfJhj7kyp8EZ5tjx+Q1V7KlJM+mfumyCm7C49J7KjnP/FHQ7MrooVBI6krQ9XotDS6UB9XoMfiAjeGP4Pv7W6YytKrVNc3MejKZYLvd4h++oN+DDCP1EAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Persona&quot;
        title=&quot;Persona&quot;
        src=&quot;/static/29476eef551e2dc9d5adb159b9b892f2/f058b/Personas.png&quot;
        srcset=&quot;/static/29476eef551e2dc9d5adb159b9b892f2/c26ae/Personas.png 158w,
/static/29476eef551e2dc9d5adb159b9b892f2/6bdcf/Personas.png 315w,
/static/29476eef551e2dc9d5adb159b9b892f2/f058b/Personas.png 630w,
/static/29476eef551e2dc9d5adb159b9b892f2/bce72/Personas.png 633w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We might start with either the context side or the expectation side. We might start by asking ourselves: here what I want from our maintainers. What kind of people are they? Or you might start by: here are our maintainers. What can I expect? It works both ways.&lt;/p&gt;
&lt;p&gt;Just by writing down persona, we make a connection between maintainer and expectation clearer and more realistic.&lt;/p&gt;
&lt;h3&gt;Persona testing: Context side&lt;/h3&gt;
&lt;p&gt;Once you have persona, you need to test your persona.&lt;/p&gt;
&lt;p&gt;It is very simple. We just look at actual maintainers and see if they fit the description.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/6c76511d006d881c3a37fbe2f5387bb3/4597d/Persona%20testing%20context.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 48.10126582278481%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA8klEQVQoz62RWYqEQBBExQOIR/BQ3sAfz+EBVRR3RVHELzdccI/BhB5mbKd7PjogyaKgovJlMLIsg+d5TNOEdV2RZRlVnudI0xRFUWDfd6rjOHDq7I/zVYwoimAYBk3TYFkW+L6PIAgQRRH1uq5/PfhpemsoCAI4joOiKHThOA5c16XueR66rsO2bfTZOeUrMzJkWZYmlCSJHpimCV3XYds2DMOAZVnQNA2qqiIMw/fIbduiLEva3zAMiOOYcJMkIeRzBVVVYRxH9H3/hP5keN3PiTbP83c/w7rqJfI1wTs9EP+V8jW5v+rdZLfIn9DHDb8AxPz3AUXHxSAAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Persona testing context&quot;
        title=&quot;Persona testing context&quot;
        src=&quot;/static/6c76511d006d881c3a37fbe2f5387bb3/f058b/Persona%20testing%20context.png&quot;
        srcset=&quot;/static/6c76511d006d881c3a37fbe2f5387bb3/c26ae/Persona%20testing%20context.png 158w,
/static/6c76511d006d881c3a37fbe2f5387bb3/6bdcf/Persona%20testing%20context.png 315w,
/static/6c76511d006d881c3a37fbe2f5387bb3/f058b/Persona%20testing%20context.png 630w,
/static/6c76511d006d881c3a37fbe2f5387bb3/4597d/Persona%20testing%20context.png 631w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In this case, we identify the gap between the actual maintainers and our ideal maintainers. Mark doesn’t have 6 years of experience, but he understands distributed systems.&lt;/p&gt;
&lt;p&gt;Once all gaps are clearly identified, we have many choices to deal with them.&lt;/p&gt;
&lt;p&gt;Aside from a clear choice of changing our architecture to fit the maintainers, we can also provide a training and capability improvement program. We can switch some team members around with other projects. We can hire someone from the outside that matches a requirement.&lt;/p&gt;
&lt;p&gt;We can even set a standard and career development. We can bring your persona to all those junior and say: We want you to be this person within a year. Once you obtain these, we can talk about promotion and next step in your career.&lt;/p&gt;
&lt;p&gt;All of the above are some examples of what we can do once gaps are clearly identified.&lt;/p&gt;
&lt;p&gt;I hope you now see the value of writing down persona.&lt;/p&gt;
&lt;p&gt;There is one thing I want you to be prepared. Seeing these gaps might lead to some hard conversations, and we might not feel comfortable about these.&lt;/p&gt;
&lt;p&gt;All I can say is that this approach works much better than design for the best and pray for the rest approach. It works much better than blindly adopting microservice, and in the end, all maintainers just want to quit or kill the project.&lt;/p&gt;
&lt;p&gt;I heard this kind of story so many times. Architecture implements fancy architecture and creates a big gap between what should happen and what actually happens.&lt;/p&gt;
&lt;p&gt;Those gaps will not go away just because we don’t think about it. So let us be mentally prepared and confront those gaps heads-on.&lt;/p&gt;
&lt;h3&gt;Persona testing: Expectation side&lt;/h3&gt;
&lt;p&gt;As we adjust our context, we still might be wrong about expectations.&lt;/p&gt;
&lt;p&gt;For example, we might think that our maintainers can independently create new feature. We might think that a senior developer will be able to facilitate post-mortem.&lt;/p&gt;
&lt;p&gt;In the end, we might be wrong.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/cc0d79b0250b737f6907d14e865fd913/76cea/Persona%20testing%20Expectation.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 37.9746835443038%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0ElEQVQoz61QOQ6DQAzcgg/xFr7D6yhpQNBwg0DcoqDknMSWFkVhkzQZaeS1vB6PLQzDgGVZIJRliaZpUNc1hmHAsixY15W5bRtHifM8oYLQNA2maXKSJAmLSWGKxKIoUFUV0jS9BknRd4onoOs65nmG53nwfR+u6zIdx0EQBMiyDHmeI4oitG17CSod2rbNzugTOYjj+GIYhux4HEd0XcdxmiZ2SXnf9/ymbWgQUfy6iawdx6GMt5X3fefip5t8G6RcWTa8NqsEPw27OcSf8QD3JmBQDrm3igAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Persona testing context&quot;
        title=&quot;Persona testing context&quot;
        src=&quot;/static/cc0d79b0250b737f6907d14e865fd913/f058b/Persona%20testing%20Expectation.png&quot;
        srcset=&quot;/static/cc0d79b0250b737f6907d14e865fd913/c26ae/Persona%20testing%20Expectation.png 158w,
/static/cc0d79b0250b737f6907d14e865fd913/6bdcf/Persona%20testing%20Expectation.png 315w,
/static/cc0d79b0250b737f6907d14e865fd913/f058b/Persona%20testing%20Expectation.png 630w,
/static/cc0d79b0250b737f6907d14e865fd913/76cea/Persona%20testing%20Expectation.png 799w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;When you have expectations and context written down, it opens up an opportunity to improve.&lt;/p&gt;
&lt;p&gt;Maybe our maintainers need more training and knowledge than we initially thought. Perhaps the way we separate our domain does not enable our maintainer to contribute. Maybe our maintainers are stuck in some legacy process or legacy code that we don’t know.&lt;/p&gt;
&lt;p&gt;There are many possible causes and possible solutions. As in product development field said, we will never get our assumption right until we launch a product into the market.&lt;/p&gt;
&lt;p&gt;And that is ok.&lt;/p&gt;
&lt;p&gt;When we know exactly where we wrong, we can make it right.&lt;/p&gt;
&lt;p&gt;It is better to say&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;I thought microservice was going to allow the team to be autonomous. It turns out that they still depend on many external services. We need to bring those services back together and rethink how we draw our domain boundaries.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;than&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;We tried, and Microservices just does not fit us.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Also, it is better to say&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;I thought a programmer with 6 years of Java development experience which demonstrates capability in OOP should be able to handle this. That is where I am wrong. It seems that the Java experience is irrelevant here. We need someone who understands how the distributed system works to maintain this system.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;than&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;We need to hire better programmers to maintain this system. Please hire only rock stars.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And personas allow you to say these types of sentences with confidence.&lt;/p&gt;
&lt;p&gt;Whether the path forward is to change our architectural decision or improve maintainers’ capability, it is much better to be explicit.&lt;/p&gt;
&lt;p&gt;And it is ok if you don’t optimize your architecture for maintainers, as long as you make it clear why and what do you expect instead.&lt;/p&gt;
&lt;p&gt;With persona, you have a clear message to all stakeholders about what you expect. You can have a meaningful conversation on how to adjust according to hiring and capability limitation.&lt;/p&gt;
&lt;h2&gt;Side Benefits&lt;/h2&gt;
&lt;p&gt;Aside from a software architecture perspective, having a clear persona can be a tool to connect many aspects of software engineering management.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hiring - What is a job description? Persona!&lt;/li&gt;
&lt;li&gt;Career growth - How shall we set junior developer expectations? Persona!&lt;/li&gt;
&lt;li&gt;Capability building - What kind of training should we provide this year? Persona!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I was in a position of tech lead who responsible for both management and architecture, and having a persona in mind helps a lot.&lt;/p&gt;
&lt;h2&gt;Endnote&lt;/h2&gt;
&lt;p&gt;Today, I introduce the concept of practical maintainability. And I think software architects should strive for it.&lt;/p&gt;
&lt;p&gt;When it comes to practical maintainability, it’s all about real humans rather than rules, processes, and practices.&lt;/p&gt;
&lt;p&gt;In the software engineering field, we mainly focus on binary and concept. In some other fields, they have many tools to deal with human inconsistency. We can learn a lot from them.&lt;/p&gt;
&lt;p&gt;To be successful in software architecture design, you rely on humans. Persona is one of many tools to help you layout dependency between your structure and human behavior. Persona testing helps you understand how your design actually works in practice.&lt;/p&gt;
&lt;p&gt;Once you have everything visualize, you have the power to solve it.&lt;/p&gt;
&lt;p&gt;I believe that just like every other type of architect, a software architect is supposed to solve a human problem. Architecture should serve human needs, not the other way around.&lt;/p&gt;
&lt;p&gt;Thanks for reading!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Code quality without familiarity]]></title><description><![CDATA[หลายๆ ครั้งผมพบว่าโปรแกรมเมอร์มักจะตัดสินคุณภาพของโค้ดจากปัจจัยเพียงแค่ว่า Pattern ที่เขาใช้ตรงกับที่เราใช้มั้ย เช่น ถ้าสมมติเราทำโค้ด MVC…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/code-without-familiarity/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/code-without-familiarity/</guid><pubDate>Sat, 06 Mar 2021 17:00:00 GMT</pubDate><content:encoded>&lt;p&gt;หลายๆ ครั้งผมพบว่าโปรแกรมเมอร์มักจะตัดสินคุณภาพของโค้ดจากปัจจัยเพียงแค่ว่า Pattern ที่เขาใช้ตรงกับที่เราใช้มั้ย&lt;/p&gt;
&lt;p&gt;เช่น ถ้าสมมติเราทำโค้ด MVC อาจจะมีทีมนึงกำหนดกฎไว้แบบนี้&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Controller ห้ามมี Logic&lt;/li&gt;
&lt;li&gt;ใน View ให้เข้าถึง Model แล้วถ้าอยากแสดงอะไรพิเศษให้เพิ่มใน Model&lt;/li&gt;
&lt;li&gt;Model เป็นที่รวม Logic ส่วนมาก รวมถึงการเข้าฐานข้อมูล&lt;/li&gt;
&lt;li&gt;ให้ใช้ Dependency Injection ในการทำให้ Unit test ได้&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ทีนี้เวลาเราไปเจอโค้ดของอีกทีมที่ใช้ Pattern อีกอย่างกับที่เราคุ้นชิน เช่น&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;หากต้องการแสดงอะไรพิเศษให้สร้าง Presenter หรือ ViewModel ขึ้นมา&lt;/li&gt;
&lt;li&gt;Controller มี Logic ในการตรวจสอบ Request ได้&lt;/li&gt;
&lt;li&gt;ให้ใช้ Stub ในการทำให้ Unit test ได้&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;เราก็อาจจะคิดว่าโค้ดนั้นห่วยเพราะมันไม่ถูกต้องตามที่เราเรียนมาหรือคุ้นชินมา&lt;/p&gt;
&lt;p&gt;ผมมองว่าการใช้ความคุ้นชินแบบนี้เป็นตัวชี้วัดว่าโค้ดมีคุณภาพมั้ยที่ไม่ดีมากๆ โค้ดหลายตัวมีคุณภาพที่ดีโดยไม่จำเป็นต้องใช้ Design Pattern ที่เรารู้จัก ตัวเราเองก็ไม่สามารถไปอ่านหรือทำความเข้าใจทุกๆ Design Pattern บนโลกนี้ได้&lt;/p&gt;
&lt;p&gt;ผมมีโอกาสอ่านโค้ดของ Candidate ทำงานกับ Legacy code มาเยอะ มีโอกาสเขียนโปรแกรมมาหลากหลายภาษา แต่ละภาษาแต่ละโค้ดเองก็มีทั้งสไตล์, Framework, Design decision, Best practices ที่แตกต่างกัน&lt;/p&gt;
&lt;p&gt;ด้วยประสบการณ์แบบนี้ ผมไม่อยู่ในฐานะที่สามารถบอกได้ว่าโค้ดไหนแย่หรือดีจากเพียงแค่เพราะมันคุ้นตามั้ย แค่เปลี่ยนภาษาก็จบเห่แล้ว ทุกอย่างต้องลบทิ้งหมด อย่างเช่น&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;วันที่ผมเปลี่ยนจาก Angular มาเป็น React งี้ ผมไม่สามารถบอกได้ละว่าโค้ดที่ดีต้องมี Dependency injection ใน React มันไม่เหมาะเอามากๆ&lt;/li&gt;
&lt;li&gt;วันที่ผมใช้เทคโนโลยี Web API กับ MVC เพื่อเขียน C# JSON API Application ก็มีความแตกต่างมากในแง่ของ Entity ที่ใช้ในระดับ API ผูกกับ Object ขนาดไหน อันนึงออกแบบบนฐานของ Coupling Entity, Response กับอีกอันคือ Decoupling เลย&lt;/li&gt;
&lt;li&gt;ตอนผมทำ Rails, C# MVC, Phoenix ถึงแม้จะเป็น MVC เหมือนกันแต่สไตล์ก็แตกต่างกันมาก&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ผมจึงอยากแชร์ว่าปกติแล้วผมดูอย่างไรว่าโค้ดไหนดีหรือโค้ดแบบไหนแย่ โดยไม่ขึ้นกับความคุ้นตาของตัวเอง&lt;/p&gt;
&lt;p&gt;งั้นเรามาเริ่มกันเลยดีกว่า&lt;/p&gt;
&lt;h2&gt;Definition&lt;/h2&gt;
&lt;p&gt;กฎข้อแรกที่สำคัญที่สุดของโค้ดที่ดีสำหรับผมคือ&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;โค้ดที่ดีสำหรับผมคือมีนิยามของคำศัพท์ที่ชัดเจน และทำตามนิยามนั้น&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ผมยกตัวอย่าง Rails บอกว่า &lt;a href=&quot;https://guides.rubyonrails.org/action_controller_overview.html&quot;&gt;Controller&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Action Controller is the C in MVC. After the router has determined which controller to use for a request, the controller is responsible for making sense of the request, and producing the appropriate output. Luckily, Action Controller does most of the groundwork for you and uses smart conventions to make this as straightforward as possible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;แปลว่า Controller มีหน้าที่จัดการ Request และจัดการ Output ถ้าเรานิยามไว้แบบนี้ แปลว่าโค้ดที่เอา Controller ไปทำอย่างอื่นคือไม่ดีละ&lt;/p&gt;
&lt;p&gt;แปลว่าผมอ่านโค้ด Rails ผมจะไม่อยากเห็น Controller ที่รู้เรื่องธุรกิจภายในมากกว่าการจัดการ Request/Response&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ruby&quot;&gt;&lt;pre class=&quot;language-ruby&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;TransactionController&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token method-definition&quot;&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;TooLowTransactionError&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; params&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token symbol&quot;&gt;:amount&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# บรรทัดนี้คือไม่ดี เพราะมันรู้ว่าในธุรกิจของเราห้ามสร้าง Transaction ต่ำกว่า 20 บาท&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;# ....&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ซึ่งแปลว่าถ้ามีใครก็ตามกำหนด Definition ของ Controller ต่างไปจากเรา เราอาจจะเอ๊ะในครั้งแรกว่าทำไมถึงกำหนดต่างกับมาตรฐานสากลล่ะ แต่ไม่ได้แปลว่าโค้ดไม่ดีนะครับ&lt;/p&gt;
&lt;p&gt;สมมติใครซักคนกำหนดว่า Controller มีหน้าที่ประสานงานระหว่าง Model ในกรณีที่ API นั้นต้องใช้มากกว่า 1 Model แล้วเขาเขียนตามนั้น นี่ก็คือถือว่ายังเป็นโค้ดที่ดีในแง่ของ Honest to definition อยู่ครับ&lt;/p&gt;
&lt;p&gt;ส่วนการกำหนด Definition แบบนี้มันเหมาะหรือไม่ จะทำให้ Controller บวมเกินเหตุมั้ย อันนั้นอีกเรื่องนึง ต้องไปดูตามบริบทของระบบที่พัฒนาอีกทีนึง&lt;/p&gt;
&lt;p&gt;หรืออย่างเช่นใน MVC แบบ Rails ตัว Model จะเข้าถึงฐานข้อมูลได้ ก็จะเขียนบอกไว้ใน Definition ของ Model แต่ถ้าเราเริ่มทำ Hexagonal Architecture เราอาจจะมี Repository ที่เข้าถึงข้อมูลอีกที ไม่ให้ Model เขาถึงฐานข้อมูลโดยตรง&lt;/p&gt;
&lt;p&gt;ทั้งสองอย่างผมมองว่าไม่ได้มีอันไหนเหนือกว่าอันไหน ขึ้นกับบริบทของระบบ&lt;/p&gt;
&lt;p&gt;แต่สิ่งที่ดีเสมอโดยไม่ขึ้นกับบริบท คือคุณมีนิยามที่ชัดเจนว่าแต่ละคำศัพท์แปลว่าอะไร และคนร่วม Contribute เข้าใจตรงกันไม่สับสน สามารถทดสอบได้ง่ายๆ คือ สมมติพูดถึง Controller ถ้าผมเป็นสมาชิกใหม่เข้าไปถามว่า สิ่งนี้ควรอยู่ใน Controller มั้ย ทุกคนควรจะตอบได้ตรงกัน&lt;/p&gt;
&lt;p&gt;สิ่งที่แย่โดยโดยไม่ขึ้นกับบริบท คือ นิยามที่ว่าแต่ละคำศัพท์คืออะไรมันกำกวม คนร่วมทีมอธิบายไม่ได้ว่า Model แปลว่าอะไร Controller แปลว่าอะไร ไปถามเจ้าตัวคนเขียนคนแรกก็ตอบไม่ได้ชัดเจนว่านิยามอะไร บอกได้แค่ประมาณนั้นอ่ะประมาณนี้อ่ะ แต่ละคนในทีมตอบไม่ตรงกันซักคน&lt;/p&gt;
&lt;p&gt;อันนี้ผมมองว่าแย่เสมอในทุกบริบทของระบบ&lt;/p&gt;
&lt;h2&gt;Consistency&lt;/h2&gt;
&lt;p&gt;ต่อเนื่องจากนิยาม ความคงเส้นคงวาก็สำคัญ&lt;/p&gt;
&lt;p&gt;ผมขอยกย่อหน้าเก่าขึ้นมา&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;หรืออย่างเช่นใน MVC แบบ Rails ตัว Model จะเข้าถึงฐานข้อมูลได้ ก็จะเขียนบอกไว้ใน Definition ของ Model แต่ถ้าเราเริ่มทำ Hexagonal Architecture เราอาจจะมี Repository ที่เข้าถึงข้อมูลอีกที ไม่ให้ Model เขาถึงฐานข้อมูลโดยตรง&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ถ้าสมมติเราวางนิยามไว้แบบนี้ แต่บางทีเวลาเห็น Model บวมเราก็สร้าง Repository ขึ้นมา บางทีก็ใช้ บางทีก็ไม่ใช้ ไม่มีความคงเส้นคงวา อันนี้ก็ถือว่าไม่ดี&lt;/p&gt;
&lt;p&gt;ไม่ว่าจะทำโค้ดในภาษาโบราณแค่ไหนไปจนถึงใหม่แค่ไหน ความคงเส้นคงวาของคำศัพท์และ Layering คือดีครับ และข้อยกเว้นยิ่งมีมากคือไม่ดี&lt;/p&gt;
&lt;p&gt;หรือสมมติถ้าเราตกลงกันแล้วว่าเราจะใช้ &lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt; เสมอ เราก็จะใช้มันเสมอ ไม่ใช้ for loop และตรงข้าม ถ้าเราตกลงกันแล้วว่าจะใช้ for loop เสมอไม่ใช้ &lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt; ก็ควรจะคงเส้นคงวากับสิ่งนั้น&lt;/p&gt;
&lt;p&gt;ถ้าจะใช้ผสมกันก็ต้องบอกได้ว่าตอนไหนใช้ &lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt; ตอนไหนใช้ loop ที่ชัดเจนเข้าใจตรงกัน&lt;/p&gt;
&lt;p&gt;การมีข้อยกเว้นได้มั้ย ได้ ถ้า Justify the cost ได้ แต่ถ้ามีไปเฉยๆ โดยไม่มีต้นสายปลายเหตุอธิบายได้ดีว่าทำไมถึงเกิดข้อยกเว้น อันนี้ผมมองว่าแย่โดยไม่เกี่ยวกับว่าออกแบบยังไง&lt;/p&gt;
&lt;h2&gt;Appropriate coupling&lt;/h2&gt;
&lt;p&gt;โค้ดที่ดีอีกอย่างนึงคือ เราเข้าใจว่าโค้ดแต่ละบรรทัดแก้ไขแล้วมีสิทธิ์กระทบอะไรบ้าง&lt;/p&gt;
&lt;p&gt;ผมยกตัวอย่างจากบทความที่ผมเขียนเองเรื่อง &lt;a href=&quot;https://dev.to/chrisza4/code-clean-13kk&quot;&gt;โค้ดเหมือนจะ Clean&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ruby&quot;&gt;&lt;pre class=&quot;language-ruby&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Invoice&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token method-definition&quot;&gt;&lt;span class=&quot;token function&quot;&gt;pay_invoice&lt;/span&gt;&lt;/span&gt;
    make_sure_invoice_approved
    create_transaction_entry
    decrease_company_total_balance
    record_tax_deduction
  &lt;span class=&quot;token keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ถ้าเราเขียนแบบนี้แล้วเราไม่สามารถทำความเข้าใจได้ว่าการแก้ไข &lt;code class=&quot;language-text&quot;&gt;create_transaction_entry&lt;/code&gt; จะกระทบกับใบเสร็จส่วนไหนบ้าง จนกว่าจะขุดลึกๆ อันนี้คือแย่&lt;/p&gt;
&lt;p&gt;ดังนั้นการออกแบบให้ Dependency ระหว่างโค้ดแต่ละส่วนเคลียร์ เข้าใจง่าย ไม่พันกันเกินไป จนสามารถพูดได้เต็มปากว่าถ้าผมแก้โค้ดบรรทัดนี้ ส่วนนี้อาจจะกระทบ และส่วนนั้นจะไม่กระทบแน่นอน&lt;/p&gt;
&lt;p&gt;นั่นคือคุณลักษณะของโค้ดที่ดี โดยไม่เกี่ยวกับ Design pattern ที่ใช้&lt;/p&gt;
&lt;h2&gt;Local reasoning&lt;/h2&gt;
&lt;p&gt;คุณสมบัติสุดทายที่ผมจะพูดถึงวันนี้คือ Local reasoning หรือความสามารถในการทำความเข้าใจแยกส่วนได้&lt;/p&gt;
&lt;p&gt;ถ้าคุณเห็นโค้ดแบบนี้&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ruby&quot;&gt;&lt;pre class=&quot;language-ruby&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token method-definition&quot;&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;# ทำทุกอย่าง&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;โปรแกรมลักษณะนี้เราต้องเข้าใจทุกอย่างที่มีในระบบก่อนที่จะแก้ไขบรรทัดนึง เพราะแต่ละบรรทัดอาจจะขึ้นกับบรรทัดอื่นได้โดยที่เราไม่รู้ จึงทำให้การทำความเข้าใจแค่ส่วนที่เราสนใจทำไม่ได้&lt;/p&gt;
&lt;p&gt;แต่ถ้าเป็นแบบนี้ล่ะ&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ruby&quot;&gt;&lt;pre class=&quot;language-ruby&quot;&gt;&lt;code class=&quot;language-ruby&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token method-definition&quot;&gt;&lt;span class=&quot;token function&quot;&gt;vat&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token variable&quot;&gt;@amount&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0.07&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;เราเร่ิมเข้าใจได้ละว่าบรรทัดนี้ขึ้นกับจำนวน &lt;code class=&quot;language-text&quot;&gt;@amount&lt;/code&gt; ในคลาสของเราเท่านั้น โดยมั่นใจได้ 100% ว่าจะไม่มี Surprise ใดๆ ออกมาที่จะมากระทบกับสิ่งนี้แบบงงๆ ได้ นอกจาก Amount&lt;/p&gt;
&lt;p&gt;การที่เราสามารถทำความเข้าใจโค้ดเป็นส่วนๆ ได้ก็สำคัญ และเป็นสาเหตุนึงที่โค้ดที่ดีมักจจะมีขนาดของ Function, Method ที่เล็ก (แต่ผมว่าเราเชียร์ว่าทำฟังก์ชั่นเล็กๆ มากไปหน่อย จนหลายๆ คนเชื่อว่าฟังก์ชั่นเล็กคือดี โดยไม่เข้าใจว่าดียังไง ผมตอบให้ว่าจริงๆ เราอยากได้ความสามารถในการทำ Local reasoning)&lt;/p&gt;
&lt;h2&gt;ส่งท้าย&lt;/h2&gt;
&lt;p&gt;จริงๆ แล้วมันมีปัจจัยอีกมากมายที่ผมดู แต่วันนี้ขอเสนอ 4 ข้อครับ&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Domain alignment&lt;/li&gt;
&lt;li&gt;Naming convention&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;แต่ 4 ข้อนี้เป็นข้อพื้นฐานที่ผมคิดว่าถ้าเริ่มมองโค้ดที่ไม่คุ้นชินจากมุมนี้ เราจะเข้าใจง่ายขึ้นว่าโค้ดที่ดีเป็นแบบไหน รวมไปถึงถ้าเราไปศึกษา Framework ใหม่ โดยเข้าใจว่า Framework ที่ดีจะมีคุณสมบัติพวกนี้ เราก็จะเข้าใจและคาดเดา (Deduce) Design บางอย่างได้อย่างรวดเร็วครับ อ่านแป๊ปเดียวก็อ๋อ เขาไว้ยังงี้นี่เอง ได้เร็วขึ้นครับ&lt;/p&gt;
&lt;p&gt;ถ้าชอบบทความนี้ ผมรบกวนกดให้กำลังใจใน &lt;a href=&quot;https://dev.to/chrisza4/code-quality-3pm&quot;&gt;dev.to&lt;/a&gt; ด้วยครับ บล็อกนี้ยังไม่ได้ทำระบบ Like หรือ View&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Agile upfront design]]></title><description><![CDATA[One of the greatest questions in software design is how much should we put effort into upfront design? Agile methodology has become a norm…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/design-upfront/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/design-upfront/</guid><pubDate>Sat, 27 Feb 2021 05:00:00 GMT</pubDate><content:encoded>&lt;p&gt;One of the greatest questions in software design is how much should we put effort into upfront design?&lt;/p&gt;
&lt;p&gt;Agile methodology has become a norm for software development, and many people argue for not design upfront. As a result, many of us claim that Agile prevents a good software design and aims to churn out endless features and technical debts.&lt;/p&gt;
&lt;p&gt;While I don’t believe that is true, I can see where this is coming from.&lt;/p&gt;
&lt;p&gt;I want to share my approach toward architectural design.&lt;/p&gt;
&lt;p&gt;(Disclaimer: I make a lot of bash in waterfall methodology in the article. When I bash it, I bash on waterfall done wrong. I am aware that effective waterfall will not end up this way.)&lt;/p&gt;
&lt;h2&gt;Two secrets of the agile design upfront&lt;/h2&gt;
&lt;p&gt;I think the first secret of upfront design can be simply put as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do the upfront design, not for the future, for a present moment&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Agile never says that we should not do any upfront design. But contrary to the Waterfall approach, &lt;strong&gt;Agile is very against the design for anticipated requirements&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Most of the waterfall projects have a fixed budget and timeline. Most of the time, the IT team is separate from business. Sometimes it is an internal team. Sometimes it is a vendor.&lt;/p&gt;
&lt;p&gt;Let say you work for HR, and you want software for your department. You need to state the requirement to the development team. They will tell you how long it would take.&lt;/p&gt;
&lt;p&gt;After you get your software, the development team will move to the next project and become busy for years until you get the next development queue again.&lt;/p&gt;
&lt;p&gt;What if you want a small workflow change after the project is delivered? You wait for a year since this year the development team will be focusing on manufacturing department projects.&lt;/p&gt;
&lt;p&gt;In this case, it makes perfect sense that the HR team will make a lot of guesses on what they want in the future because changes after delivery are very slow.&lt;/p&gt;
&lt;p&gt;Now you can see how Waterfall incentivizes guessing future requirements. Sometimes we even asked them to guess.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Will you need to do X in the future? Because we need to design for that upfront.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A team which familiar with waterfall methodology, with their best intention, will likely demand a customer to think of all possible requirements upfront. So they can design and lay the foundation to make it possible to scale for the future.&lt;/p&gt;
&lt;p&gt;That is the waterfall upfront design.&lt;/p&gt;
&lt;p&gt;I saw people blaming agile for bad software design and technical debt. I worked on a waterfall project, and I’ve seen worse. A strategy pattern for one strategy. An observer pattern for one observer. A factory of factory of adapter for only a single adapter implementation. I saw it all. Everything is abstract and extensible, without a clear need. Because of … future!!&lt;/p&gt;
&lt;p&gt;Why this approach mostly fail? The harder we think about the future, the better software architecture should be, right?&lt;/p&gt;
&lt;p&gt;Here comes the second secret:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;No one can predict future requirements with certainty.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yes. The problem lies in the fact that we basically squeeze out a future requirement from a customer in waterfall methodology.&lt;/p&gt;
&lt;p&gt;Then we design upfront for that “future,” and then blame customers when that future never comes, and we have to maintain a bloated software.&lt;/p&gt;
&lt;p&gt;You know how we talk about how hard it is to estimate a timeline for feature development, right? We know that many factors come to play. There might be a bad tech debt in the current codebase. The specs might be unclear. The library might not work as well as we initially thought.&lt;/p&gt;
&lt;p&gt;The requirement anticipation is also that hard. The business landscape might change. The person who wants the feature might get fired. The key employee might resign, and the whole organization structure might need to change.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I want us to be more empathetic toward business requirement gathering. It is very unfair for us to demand #NoEstimate because it is hard while also demanding to get every future requirement laid out upfront to design our program correctly.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Don’t be that entitled.&lt;/p&gt;
&lt;p&gt;In my experience, the waterfall project gets a lot of technical debt as well. There are much non-sense code or design pattern which, I believe, designed for those anticipated requirements that the team force out of business and never come true.&lt;/p&gt;
&lt;p&gt;So two secrets come to play in the Agile way to design upfront:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Contrary to popular belief of design upfront is for the future: We focus on design for current requirements.&lt;/li&gt;
&lt;li&gt;Future requirements are mostly bullshit. That is why we don’t design for that.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Approach towards future&lt;/h2&gt;
&lt;p&gt;When I said stop design for future requirements, there is a big caveat.&lt;/p&gt;
&lt;p&gt;There is no guarantee that any requirement will actually be something the user will want until we finished the software. So every requirement is essentially a future requirement.&lt;/p&gt;
&lt;p&gt;In practice, I draw the line between present requirement and future requirement based on the confidence level.&lt;/p&gt;
&lt;p&gt;For example, let say there are two requirement&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The system needs to be able to handle 1,000 req/sec (99%)&lt;/li&gt;
&lt;li&gt;The system needs to be able to handle 1,000,000 req/sec (30%)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both of them are not required today since we don’t have a single user yet. But since we are really confident that 1,000 req/sec is required, I will design for just that. I would not think about 1,000,000 req/sec.&lt;/p&gt;
&lt;p&gt;Or this might hit closer to the home.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User needs to be able to login using Google Account (99% confidence. All of the target users are using Google)&lt;/li&gt;
&lt;li&gt;User needs to be able to login using LDAP (30%, might happen when we know how to market to Enterprise)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then I will design for only Google Account login. I might use a standard protocol implementation (OAuth), but in the end I would not worry about making sure the system can handle LDAP without refactoring.&lt;/p&gt;
&lt;p&gt;You can imagine the difference. In the waterfall project, the customer might ask us to support LDAP even if it not need because the customer was afraid that they would need it in the future. We will be too busy to get back and help them. So we need to “design upfront” for that future requirement.&lt;/p&gt;
&lt;p&gt;That leads to a terrible software design—a design for something that does not actually exist.&lt;/p&gt;
&lt;p&gt;In Agile, I design for only current requirements. Since everything is essentially happening in the future, I define a requirement with a high confidence level as the current requirement.&lt;/p&gt;
&lt;p&gt;For Google login, I can use OAuth. I can make an authentication services. I can put some thought on session timeout. I need to think about cookie or token. I need to think about interface of auth service and callback. That is the design phase. But I don’t think about design and interface, network diagram and service layer that can handle LDAP at this point.&lt;/p&gt;
&lt;p&gt;That is the Agile upfront design.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;To wrap up: I believe that we should think about software design. We should not become a code-monkey and churning out feature regardless of tech debt.&lt;/p&gt;
&lt;p&gt;We also need to accept that the future is unpredictable. Instead of upfronting design based on what might happen in the future, I believe we should do upfront design just for the current requirement (which can be defined by working closely with the customer as in Agile Manifesto).&lt;/p&gt;
&lt;p&gt;That’s all I have to say. Thanks for reading.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[We don't need "more documentation"]]></title><description><![CDATA[There are many sentiments around code documentation. On the one side, some advocates for self-documented code, and another side advocate for…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/the-documentation/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/the-documentation/</guid><pubDate>Mon, 08 Feb 2021 17:00:00 GMT</pubDate><content:encoded>&lt;p&gt;There are many sentiments around code documentation. On the one side, some advocates for self-documented code, and another side advocate for more documentation.&lt;/p&gt;
&lt;p&gt;Truth be told, my main motivation toward writing this article is based a &lt;a href=&quot;https://www.reddit.com/r/programming/comments/le46br/why_you_need_architecturemd/&quot;&gt;Reddit’s Thread&lt;/a&gt;, esp this &lt;a href=&quot;https://www.reddit.com/r/programming/comments/le46br/why_you_need_architecturemd/gm9zut3?utm_source=share&amp;#x26;utm_medium=web2x&amp;#x26;context=3&quot;&gt;comment&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;In this article, I would like to show my thought on the topic. There are some rants I need to get off my chest.&lt;/p&gt;
&lt;h2&gt;Manager: merely more documentation does not help&lt;/h2&gt;
&lt;p&gt;I have so many thoughts about documentation. But if I have only one bullet to make a point: this will be it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Many people working in the software industry assume documentation is easier to understand than a codebase. That assumption is not correct. Worst of all, it is not even close to the truth.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When a manager landed into a challenging hand-off project. They wish for more documentation. Sometimes, they might force a developer to write documentation with a good intention of making future maintenance work easier.&lt;/p&gt;
&lt;p&gt;But let me ask a blunt question here. When you force a developer to rewrite a set of unambiguous logical instruction steps into an ambiguous language, human language, do you actually help your developers?&lt;/p&gt;
&lt;p&gt;Here is the metaphor. You have a Spanish novel. You ask an author to translate it into English. You sent it to a person who proficient in Both English and Spanish. Which version do you think they will prefer?&lt;/p&gt;
&lt;p&gt;In my experience, it almost always easier to reason within the code.&lt;/p&gt;
&lt;h2&gt;Developer: Ask for what you need&lt;/h2&gt;
&lt;p&gt;When a developer faced a complex legacy system, they wish for more documentation. They might start to blame the previous maintainer for the lack of documentation.&lt;/p&gt;
&lt;p&gt;They might start asking for documentation or even advocate for the whole company to produce more documentation.&lt;/p&gt;
&lt;p&gt;Now let me ask you a blunt question again.&lt;/p&gt;
&lt;p&gt;You have a person who struggles to express the logical steps in a well-structured, readable manner with the language designed for it. What makes you think that forcing this person to describe those logical steps again in a human language designed for ambiguous unstructured storytelling will make it easier to read?&lt;/p&gt;
&lt;p&gt;Turns out, this is a terrible idea.&lt;/p&gt;
&lt;p&gt;I found that most of the documentation produced by some policy or checkbox, which essentially forcing a developer to write in the virtue of “we need more documentation”, will be messier than the codebase itself.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Ironically, the one who can write good documentation will write code that does not require heavy documentation.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Please, think carefully about what you really need.&lt;/p&gt;
&lt;p&gt;I understand how it feels to work in a legacy system. But asking for random documentation will not help.&lt;/p&gt;
&lt;p&gt;Because essentially, what we need is specific information, not the documentation. The core part is the information itself, and documentation is just one possible format.&lt;/p&gt;
&lt;p&gt;Understand what you really need. Don’t be reactionary. Just because you are working on a painful project and documentation does not exist there, it doesn’t mean you need more random documentation.&lt;/p&gt;
&lt;p&gt;I see many developers ranted about a customer giving them a solution, possibly a stupid one, rather than stating the problem. You know the type, the type who will tell you to implement some kind of Deep learning AI with Blockchain in his personal blog because all these fancy techs will magically solve his problem. You hate that guy, right?&lt;/p&gt;
&lt;p&gt;Don’t be that guy. Don’t ask for just more documentation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;State the problem, not the solution.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If that’s the mindset we want from our customers, we better set an example ourselves.&lt;/p&gt;
&lt;p&gt;Stop demanding more documentation, and start to ask for missing information.&lt;/p&gt;
&lt;h2&gt;Code is just a part of system documentation&lt;/h2&gt;
&lt;p&gt;Having all that said, I will not say that we should just write a self-documented code, and we will never need documentation again.&lt;/p&gt;
&lt;p&gt;Code cannot capture every useful information about the system.&lt;/p&gt;
&lt;p&gt;There are many aspects that you cannot express in the codebase. Here are some examples&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The intention. Why is the code writing this way? How do you want everything to be connected?&lt;/li&gt;
&lt;li&gt;The norm. It is better to read about the standard way of doing things in the documentation than reading through at least 51% of the codebase to deduce.&lt;/li&gt;
&lt;li&gt;Deployment process.&lt;/li&gt;
&lt;li&gt;Assumptions.&lt;/li&gt;
&lt;li&gt;Invisible constraint of the system.&lt;/li&gt;
&lt;li&gt;Overall architecture.&lt;/li&gt;
&lt;li&gt;Strategic architectural decisions that happened in the past.&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The code cannot express these types of information. So whenever you document these, you bring some values.&lt;/p&gt;
&lt;p&gt;You can advocate for both documentation and self-documented code. That helps. Still, there are many things that code cannot express. Self-documented code is just a part of whole documentation.&lt;/p&gt;
&lt;h2&gt;Final Thought&lt;/h2&gt;
&lt;p&gt;This article is kind of a rant. Still, I believe we make the matter worst whenever we advocate for us to document more.&lt;/p&gt;
&lt;p&gt;So developer, stop asking for more documentation. Instead, understand what information do you really want and ask for that. Maybe it can come in the form of good old documentation. Perhaps it can come in a form of an executeable document (aka. code). Doesn’t matter.&lt;/p&gt;
&lt;p&gt;So manager, stop asking for more documentation. Instead, I gave you a list of many things that the codebase itself cannot express. Ask your developer to document those, not some kind of documentation.&lt;/p&gt;
&lt;p&gt;Also, a person who writes an unmaintainable codebase tends to write an also unmaintainable documentation. So don’t fall into a trap that more documentation always helps. Instead, it would be best to ask for validation with another developer.&lt;/p&gt;
&lt;p&gt;That’s all I have to rant. Thanks for reading.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Code to reflect of truth]]></title><description><![CDATA[Let say you are building an ERP application with a role-based authorization system. Let say we are building this for a company. In this…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/reflecting-the-knowledge/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/reflecting-the-knowledge/</guid><pubDate>Tue, 02 Feb 2021 17:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Let say you are building an ERP application with a role-based authorization system.&lt;/p&gt;
&lt;p&gt;Let say we are building this for a company. In this company, we have Jane. Jane is a long-time employee with a lot of influence. What she has to say is pretty important.&lt;/p&gt;
&lt;p&gt;After some sprints passed, she looked into our demonstration, and she wanted to hide a specific menu in the main menu screen, as it is not relevant to her workflow.&lt;/p&gt;
&lt;p&gt;Usually, the system would display a different set of menus for each role. So we considered if we should hide this menu for Jane’s role? In this case, the specific menu is relevant to every employee in Jane’s role, but not Jane (for some reason).&lt;/p&gt;
&lt;p&gt;After a long negotiation, we concluded that we need to work on Jane’s change request.&lt;/p&gt;
&lt;p&gt;Now, we might go with this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;csharp&quot;&gt;&lt;pre class=&quot;language-csharp&quot;&gt;&lt;code class=&quot;language-csharp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;currentUser&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;email &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;jane@thecompany.com&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;settingMenus&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hide&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But wait, I can see some programmer scream at this line of code. We should not be hardcoding the stuff. It is a bad practice. Sloppy work!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Now, if we get back to the requirement, what are the options to implement this?&lt;/p&gt;
&lt;p&gt;I can see three options.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a preference system where everyone can configure what they want to see in the main menu&lt;/li&gt;
&lt;li&gt;Make a specific role for Jane and hide the menu according to the role&lt;/li&gt;
&lt;li&gt;Hardcoding&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And let’s evaluate each option:&lt;/p&gt;
&lt;p&gt;The first option seems to be overkill for just one person’s request. It will blow out the budget and timeline.&lt;/p&gt;
&lt;p&gt;In the second option, we create a role to conform to the current structure of the application. We might be able to create &lt;code class=&quot;language-text&quot;&gt;ACCOUTANT_BUT_FOR_JANE&lt;/code&gt;, which is another role. We can copy all the role configuration and permission from &lt;code class=&quot;language-text&quot;&gt;ACCOUNTANT&lt;/code&gt;. But then whenever the requirement for role &lt;code class=&quot;language-text&quot;&gt;ACCOUNTANT&lt;/code&gt; change, we need to make sure that &lt;code class=&quot;language-text&quot;&gt;ACCOUNTANT_BUT_FOR_JANE&lt;/code&gt; will be in sync and does not accidentally show Jane that disgusting menu.&lt;/p&gt;
&lt;p&gt;In the third option, it is simply a bad practice. Any good programmer should not be going around doing things the easy way and hardcoding stuff. They should implement everything in the right way.&lt;/p&gt;
&lt;p&gt;But is it? Is hardcoding is an easy sloppy way to implement this requirement?&lt;/p&gt;
&lt;p&gt;I would argue that since this request is a personal request from Jane herself, the hardcoding would reflect the truth in the most honest way.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;csharp&quot;&gt;&lt;pre class=&quot;language-csharp&quot;&gt;&lt;code class=&quot;language-csharp&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;currentUser&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;email &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;jane@thecompany.com&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;settingMenus&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hide&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code tells us that we hide this menu just for Jane. We don’t want to hide the menu because it appropriates some kind of new role &lt;code class=&quot;language-text&quot;&gt;ACCOUNTANT_BUT_NOT_JANE&lt;/code&gt; in the company that emerges from business need. It just simply Jane’s needs.&lt;/p&gt;
&lt;p&gt;It is a clear message to developers as well. If two years from now: Jane retired and &lt;code class=&quot;language-text&quot;&gt;jane@thecompany.com&lt;/code&gt; become reserved, this code will be dead, and we can simply remove the code.&lt;/p&gt;
&lt;p&gt;If we follow the unit test practices, we will even have a unit test:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;csharp&quot;&gt;&lt;pre class=&quot;language-csharp&quot;&gt;&lt;code class=&quot;language-csharp&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token attribute&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token return-type class-name&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ShouldHideComplicatedSettingMenuForJane&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So I think that when we code, reflecting the truth and nature of the requirement is way more important than conforming to the structure and “best practices”.&lt;/p&gt;
&lt;p&gt;It’s ok to leave the code but with some comment to explain the context. In this case, we hardcode it because it is Jane’s personal request, and she refuses to work with the system unless we hide the menu. We can put that into the comment.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Sometimes, we don’t be totally honest with the requirement. We want the code to looks good, looks consistence and have a well-defined structured. That is what good code look like.&lt;/p&gt;
&lt;p&gt;But somtimes, the truth is the requirement and human desired can be messy.&lt;/p&gt;
&lt;p&gt;And from what I see, many times developers (including me) hate this messiness and don’t want to make a code to reflect the messy reality. So we put some fancy stuff and abstraction over it.&lt;/p&gt;
&lt;p&gt;For example, We might disdain the practice of hardcoding to just “Jane” so we might put an abstraction over it to make it seems more likable, more consistent, better structured, etc. That structure can be some role, configuration, or whatsoever.&lt;/p&gt;
&lt;p&gt;I think those abstractions will blur the real truth and nature of the requirement. And make the system even harder to maintain. It reduce the quality of the code by acting as a sophicicated sheet to covered up the actual system requirement.&lt;/p&gt;
&lt;p&gt;I think we should be honest with the requirement. If it is Jane’s personal request, make it clear that it is her personal request. reflect it truthfully no matter how messy it is.&lt;/p&gt;
&lt;p&gt;And the truth shall set you free.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[The software rewrite dilemma]]></title><description><![CDATA[Imagine this: You’ve been assigned to a legacy project. It does not have any tests. It used an ancient coding style or no consistent style…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/rewriting-dillema/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/rewriting-dillema/</guid><pubDate>Sun, 24 Jan 2021 05:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Imagine this: You’ve been assigned to a legacy project. It does not have any tests. It used an ancient coding style or no consistent style at all. Global variables are everywhere. Everything is such an incomprehensible mess.&lt;/p&gt;
&lt;p&gt;In this type of project, there is always someone who says&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The whole thing is a mess and unmaintainable. We need to rewrite everything from scratch.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I believe any seasoned software developer experienced this at some point in their career.&lt;/p&gt;
&lt;p&gt;And then, some of them are lucky enough to have a chance to start rewriting everything from scratch.&lt;/p&gt;
&lt;h2&gt;The ambitious rewrite project&lt;/h2&gt;
&lt;p&gt;After a while, many problems arises. The rewrite project has been ongoing for a year. There is no sign of an end at all.&lt;/p&gt;
&lt;p&gt;The business started to doubt the project. The engineering team started to say that requirement is not clear. The team started to reveal some hidden secret features in the current system that maybe only one or two customers use, but still, we must implement it. Worst of all, the new green-field architecture you designed was never meant to handle this type of feature.&lt;/p&gt;
&lt;p&gt;Deadline is looming, and you don’t even know how far are you from the finish line. How much effort do we need to put on until we can truly replace the old system? I don’t know, but everyone, please keep going.&lt;/p&gt;
&lt;p&gt;Many ambitious rewrite projects failed miserably. &lt;a href=&quot;https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/&quot;&gt;Joel Spolsky&lt;/a&gt; already wrote a great article about how this strategy has a strong tendency to failed.&lt;/p&gt;
&lt;p&gt;But contrast to this, in my career, I successfully rewrote two systems.&lt;/p&gt;
&lt;p&gt;The first system is the one I worked on for a while. I started that project by putting every business logic in stored procedures, and after a while, I realized that it becomes unmaintainable. So, I rewrote everything and move most of the business logic into the codebase.&lt;/p&gt;
&lt;p&gt;The second system, which I inherited, is very messy. I decided to rewrite the whole frontend and move it to another framework (and Angular 1 was still a thing).&lt;/p&gt;
&lt;p&gt;At the same time, I saw my friend had many failed stories to tell, both personally and sometimes in the article. So I start to think, what are the differences?&lt;/p&gt;
&lt;p&gt;And here is my assumption&lt;/p&gt;
&lt;h2&gt;The great dillema&lt;/h2&gt;
&lt;p&gt;Now, here’s the kicker:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“You need to be unfamiliar with the system to see the value of the rewrite. But you need to be very familiar with the system to successfully rewriting it.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What I see in most of the rewrite project looks like this.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A team of programmers started working on a legacy system.&lt;/li&gt;
&lt;li&gt;They found that the system is really hard to understand and hard to work with.&lt;/li&gt;
&lt;li&gt;They fed up with the legacy codebase. They give up on it. They start suggesting a rewrite.&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;The project fail to deliver or very lacklusting.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And the main difference between those project and my experience is simply, &lt;strong&gt;I did not give up on the old codebase&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Most of the time, this is step four.&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;After the rewrite project was approved, programmers start to treat the legacy system as a black box. They refuse to touch it with a ten-foot pole. They only look into specs and build the new system accordingly.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That is different from what I did. In my success rewrite, I never treat it at a black box.&lt;/p&gt;
&lt;p&gt;In the first project, I understand my messy stored procedures’ ins-and-outs, and it took me only a week and few days to move almost every business logic to the core code.&lt;/p&gt;
&lt;p&gt;The second project was a mess, and I have permission to rewrite it. I spent a great amount of time during the rewrite mapping out the relationship between the current messy front-end codebase and the features.&lt;/p&gt;
&lt;p&gt;At this point, I believe every successful rewrite required a significant level of understanding of the legacy system.&lt;/p&gt;
&lt;p&gt;Ironically, most programmers suggest the rewrite because they don’t want to work with the legacy system anymore. They want to be free from it. They don’t want to understand it.&lt;/p&gt;
&lt;p&gt;And that is the dilemma. Only one who brave enough to dig into legacy system, are the only one who capable of escaping.&lt;/p&gt;
&lt;h2&gt;Don’t avoid legacy code&lt;/h2&gt;
&lt;p&gt;I have one good news and one bad news.&lt;/p&gt;
&lt;p&gt;Good news: It is totally possible to rewrite the legacy system and make it much cleaner, smoother, and easier to work with. I did that before.&lt;/p&gt;
&lt;p&gt;Bad news: To succeed in the rewrite, you need to dig even deeper and get even closer to that legacy system you desperately want to avoid.&lt;/p&gt;
&lt;p&gt;In my experience: You can never trust a spec in a rewrite project. You need to look into the spec, map it with the current legacy code, see if there is any little tiny secret, and refine the specs accordingly.&lt;/p&gt;
&lt;p&gt;Sometimes those tiny little secrets can be throw away, sometimes not. You never know. But the only way to know is to lay it out. And the only way to lay it out is to become an expert in the legacy code.&lt;/p&gt;
&lt;p&gt;Then the dilemma might kick-in, because once you are familiar with and understand the legacy system’s ins-and-outs, you might not feel an urge to rewrite everything anymore.&lt;/p&gt;
&lt;p&gt;That is okay. If you still remember why do you want to rewrite the whole thing in the first place, then you will make a better-informed decision.&lt;/p&gt;
&lt;p&gt;Sometimes you might decide to rewrite only a few parts, and sometimes you might decide to refactor it just a little bit.&lt;/p&gt;
&lt;h2&gt;The hard truth&lt;/h2&gt;
&lt;p&gt;The real hard truth here is&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Once you touch legacy code, there is no escape&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you want to move away from those messy, ugly, incomprehensible dirty code, you want to create a rewrite, then the faster you dig into it, the quicker you will move away.&lt;/p&gt;
&lt;p&gt;I repeat: There is no escape.&lt;/p&gt;
&lt;p&gt;Sometimes developers use the rewrite as an escape hatch. They don’t want to touch those ugly, incomprehensible dirty codes. They cannot maintain it effectively, so they want to rewrite it.&lt;/p&gt;
&lt;p&gt;And I sympathize with that sentiment. I understand how it feels.&lt;/p&gt;
&lt;p&gt;But still, I repeat: There is no escape.&lt;/p&gt;
&lt;p&gt;Using the rewrite project as an escape mechanism will never end well.&lt;/p&gt;
&lt;p&gt;I found that there are only two types of rewrite success story:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rewrite with full Rebrand of product, such as &lt;a href=&quot;https://medium.com/@herbcaudill/lessons-from-6-software-rewrite-stories-635e4c8f7c22&quot;&gt;Basecamp, VSCode&lt;/a&gt; and Windows 10. That required business decision to drop some of backward compatibility and whole marketing effort to rebrand as a new software package.&lt;/li&gt;
&lt;li&gt;Rewrite from the experience of legacy code. You start writing specs. Then you map all observable features to the legacy code. You read through all that to uncover all little secrets there. Then you define true specs. Only from that you can start a rewrite.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And if you don’t have the liberty to go with the first choice, I repeat again.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Once you touch legacy code, there is no escape&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The sooner you accept this statement into your heart, the quicker you can get away from legacy code.&lt;/p&gt;
&lt;p&gt;It works for me. As I started to submit myself to the fact that I need to read and understand legacy code, ironically, I began to get more and more opportunities to rewrite, refactor and eventually get away from it.&lt;/p&gt;
&lt;p&gt;The world is pretty ironic, and thanks for reading.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[My favorite blogs]]></title><description><![CDATA[These are some of the blogs I enjoy. I will share it here. Tradable Quality Hypothesis Martin Fowler put good content on why we might…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/favorite-contents/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/favorite-contents/</guid><pubDate>Sat, 23 Jan 2021 17:00:00 GMT</pubDate><content:encoded>&lt;p&gt;These are some of the blogs I enjoy. I will share it here.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://martinfowler.com/bliki/TradableQualityHypothesis.html&quot;&gt;Tradable Quality Hypothesis&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Martin Fowler put good content on why we might wrongly perceive internal quality and design as trade-offs for cheaper development. I agree that just like how we can buy a lower quality phone for lower prices, we can make a lower external quality software (eg. Non-performance critical. Non-optimal user interface) for the sake of lowering budget. However, it will be different story when it comes to internal quality.&lt;/p&gt;
&lt;p&gt;I am not saying that we must over-engineer everything we build. I think we need to be aware that buying cheaper mobile with fewer features and buying ill design software for a cheaper budget, let it be time or money, is not comparable in many ways.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://martinfowler.com/bliki/TradableQualityHypothesis.html&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://medium.com/javascript-scene/the-forgotten-history-of-oop-88d71b9b2d9f&quot;&gt;The Forgotten History of OOP&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Eric Elliot is one of the functional programming advocates. He wrote a great article about what OOP was initially supposed to be. This article is great content that captures the original idea of OOP.&lt;/p&gt;
&lt;p&gt;I am not a person who always advocates for any “Original stuff”. I firmly believe that, in general, the extended version of anything will be better than the original version. But in the OOP case, I agree with Alan Kay that the real value of the Object-oriented paradigm comes from multiple subsystems communicate via message instead of shared memory. Our industry emphasizes design pattern, base classes, and inheritance tree shy us away from the deep and real merit of OOP design.&lt;/p&gt;
&lt;p&gt;It does provide value to a certain degree. But if we apply Pareto’s 80/20 rules here, I would say inheritance and base class design provides the 20% side.&lt;/p&gt;
&lt;p&gt;I should write on this more sometimes. I touch the surface of this topic in the article &lt;a href=&quot;https://dev.to/chrisza4/composition-over-inheritance-1ojg&quot;&gt;Composition over Inheritance&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;CALM Theorem&lt;/h1&gt;
&lt;p&gt;Design a program on a distributed system is hard. As an industry, we are not 100% aware of limitations when you take a single node application and make it distributed.&lt;/p&gt;
&lt;p&gt;I love theorem. CAP Theorem talks about the trade-offs when you go distributed. That makes me feel at ease because I never again had to judge myself for not thinking hard enough to design a consistent and available program.&lt;/p&gt;
&lt;p&gt;CALM Theorem talk is another fantastic theorem.&lt;/p&gt;
&lt;p&gt;CALM talks about how to know if you need massive coordination. For example: If you design a highly-available stream-based average calculator. You have a program in multiple nodes calculate the average for redundancy. It is possible that each node might not yield the same result at a given time. Do you need a consensus resolver? Or you can just wait for it to be eventually consistent? The answer is: If you design a program in a specific way, then you can wait for it to be eventually consistent.&lt;/p&gt;
&lt;p&gt;I wish for this theorem to gain more traction.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1901.01930&quot;&gt;Paper&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[SOLID Javascript without Classes]]></title><description><![CDATA[I gave a talk in Javascript Bangkok. It is about how you can use SOLID principle in Javascript without classes and objects. My main…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/js-without-classes/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/js-without-classes/</guid><pubDate>Thu, 14 Jan 2021 17:00:00 GMT</pubDate><content:encoded>&lt;p&gt;I gave a talk in &lt;a href=&quot;https://javascriptbangkok.com/&quot;&gt;Javascript Bangkok&lt;/a&gt;. It is about how you can use SOLID principle in Javascript without classes and objects.&lt;/p&gt;
&lt;p&gt;My main motivation is to show the root of SOLID. I believe we can gain deeper understanding of what is an essence of SOLID and what is just simply an implementation, by looking at another manifestation of SOLID principle.&lt;/p&gt;
&lt;p&gt;Looking back, I still love the content, but I could work more on presentation esp. the tone of voice and body language.&lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;gatsby-resp-iframe-wrapper&quot; style=&quot;padding-bottom: 56.49999999999999%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem&quot; &gt; &lt;div class=&quot;embedVideo-container&quot;&gt; &lt;iframe title=&quot;&quot; src=&quot;https://www.youtube.com/embed/R3fv__odSbI?rel=0&quot; class=&quot;embedVideo-iframe&quot; style=&quot;border:0; position: absolute; top: 0; left: 0; width: 100%; height: 100%; &quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Feedback are welcomed in &lt;a href=&quot;mailto:chakrit.lj@gmail.com&quot;&gt;email&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Why I blog here.]]></title><description><![CDATA[Hi. I have been blogging in both Medium and dev.to for a really long time. It’s time for me to try hosting my own blog, so here it is. Here…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/new-beginnings/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/new-beginnings/</guid><pubDate>Tue, 12 Jan 2021 17:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hi. I have been blogging in both &lt;a href=&quot;https://medium.com/@chrisza&quot;&gt;Medium&lt;/a&gt; and &lt;a href=&quot;https://dev.to/chrisza4&quot;&gt;dev.to&lt;/a&gt; for a really long time.&lt;/p&gt;
&lt;p&gt;It’s time for me to try hosting my own blog, so here it is.&lt;/p&gt;
&lt;p&gt;Here is a &lt;a href=&quot;https://github.com/chrisza4/chris-blog&quot;&gt;source code of this blog&lt;/a&gt;. I wrote a scraper for some content platform that I put a content into, so you can use those as an inspiration or prototype.&lt;/p&gt;</content:encoded></item></channel></rss>